#include <iostream>
#include <mutex>
#include <pthread.h>
using namespace std;

struct arg_struct{
  float* mat_a;
  float* mat_b;
  float* mat_c;
};

mutex mtx;
//for now use N
//#define N 10
int con_i;

//#define ij(i,j) (N*i+j)//superfast macro to lookup on 1d array

void multiply(float* mat_a,float* mat_b,float* mat_c,int N) 
{
  float temp[N];//for now N
  for (int j = 0; j < N; j++) 
    { 
      temp[j] = 0; 
      for (int k = 0; k < N; k++)
	{//mat_c[con_i*N+j]
	  mat_c[con_i*N+j] += pass->mat_a[con_i*N+k] *  
	    pass->mat_b[k*N+j];
	}
    }

}

void threadRipper(float* mat_a,float* mat_b,float* mat_c,int N)
{
  struct arg_struct* pass = (struct arg_struct*)malloc(sizeof(struct arg_struct));
  pass->mat_a = mat_a;
  pass->mat_b = mat_b;
  pass->mat_c = mat_c;
  pass->counter = 0;
  
  int num_cores = 2;
  pthread_t threads[num_cores];
  
  for(int i=0;i<num_cores;i++)
    {
      pthread_create(threads[i],NULL,multiply,(void *)pass);
      pass->counter = num_cores;
      //row inc
    }
}

int main()
{
  int i,j;
  int N = 10;
  struct arg_struct* pass = (struct arg_struct*)malloc(sizeof(struct arg_struct));
  cout<<"prints before malloc"<<endl;
  pass->mat_a = (float*)malloc(N*N*sizeof(float));
  pass->mat_b = (float*)malloc(N*N*sizeof(float));
  pass->mat_c = (float*)malloc(N*N*sizeof(float));
  pass->counter = 0;
  cout<<"does not make it to malloc"<<endl;
  cout<<pass->counter<<endl;
  int count = 0;

  //intialize the matrice's
  for (i = 0; i < N; i++) 
    { 
      for (j = 0; j < N; j++)
	{
	  count++;
	  pass->mat_a[N*i+j] = i+1;
	  pass->mat_b[N*i+j] = i+1;
	  pass->mat_c[N*i+j] = 0;
	}
    }

  //without threading
  for(i=0; i < N; i++)
    {
      con_i = i;
      multiplyRow(pass->mat_a, pass->mat_b, pass->mat_c, N);
    }

  //threadRipper(pass->mat_a,pass->mat_b,pass->mat_c,N);
  
  
  cout << "Result matrix is \n"; 
  for (i = 0; i < N; i++) 
    { 
      for (j = 0; j < N; j++) 
	cout << pass->mat_c[N*i+j] << " "; 
      cout << "\n"; 
    }

  free(pass->mat_a);
  free(pass->mat_b);
  free(pass->mat_c);
  return 0;
}
